"""Обработка исключительных ситуаций в Python

На протяжении курса мы регулярно сталкивались с ошибками в программах. Python
выдавал несколько строк красного текста в консоль — результат трассировки
ошибки. И после такого программа переставала работать.
Встроенный в язык механизм обработки исключений позволяет изменить
поведение программы при появлении ошибки. Впрочем, некоторые ошибки
действительно должны завершать программу. О них подробнее чуть позже в этой
лекции.
А пока рассмотрим простой пример кода и результат его выполнения
Код:"""

num = int(input('Введите целое число: '))

"""Результат
Введите целое число: сорок два
Traceback (most recent call last):
File "C:\Users\main.py", line 1, in <module>
num = int(input('Введите целое число: '))
ValueError: invalid literal for int() with base 10: 'сорок два'
Process finished with exit code 1


Программа запросила целое число, пользователь написал “сорок два” и мы
получили ошибку ValueError. Красный текст — результат трассировки ошибки.
Читать его лучше построчно снизу вверх. Самая нижняя строка указывает какую
именно ошибку мы получили и почему. Строкой выше указывается строчка кода,
повлёкшая ошибку. Отдельно Python указывает название файла с номером строки
для быстрого перехода к месту ошибки. При этом строчек с кодом и указаниями на
строки ошибки может быть несколько. Зависит от того как долго ошибка
распространялась по цепочке кода.
Посмотрите на код ниже."""


def get(text: str = None) -> int:
    data = input(text)
    num = int(data)
    return num


if __name__ == '__main__':
    number = get('Введите целый делитель: ')
    print(f'100 / {number} = {100 / number}')


"""Попробуем и тут ввести “сорок два”
Введите целый делитель: сорок два
Traceback (most recent call last):
File "C:\Users\main.py", line 8, in <module>
number = get('Введите целый делитель: ')
File "C:\Users\main.py", line 3, in get
num = int(data)
ValueError: invalid literal for int() with base 10: 'сорок два'
Process finished with exit code 1
Ошибка точно такая же. Но теперь трассировка показывает, что ошибка возникла в
третьей строке кода при приведении данных к целому типу. А чуть ранее мы
вызвали функцию get в строке 8, которая и заставила выполнятся третью строчку
кода.
Чтение трассировки помогает найти источник ошибки. Python и тут проявляет
максимальное дружелюбие к разработчику и даёт максимально возможное
количество информации об ошибке. Если вы писали на других языках, скорее всего
вы уже заметили это дружелюбие."""
