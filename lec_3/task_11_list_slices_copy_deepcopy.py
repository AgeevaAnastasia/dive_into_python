"""Создание копий
Мы уже разобрали способы создания отсортированной копии списка, развернутой
копии списка. На этом возможности копирования не заканчиваются.

Срезы
Используя квадратные скобки можно делать частичные копии списка - срезы.
Базовый синтаксис следующий.

list[start:stop:step]

start указывает на первый индекс, который включается в срез. При отсутствии
значения start равен нулю, началу списка.
stop указывает на последний индекс, который не включается в срез. При отсутствии
значения stop равен последнему элементу списка и включает его в срез.
step — шаг движения от star до stop. По умолчанию step равен единице, все
элементы по порядку."""

my_list = [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
print(my_list[2:7:2])
print(my_list[:7:2])
print(my_list[2::2])
print(my_list[2:7:])
print(my_list[8:3:-1])
print(my_list[3::])
print(my_list[:7:])



"""Метод copy()
Метод copy создаёт поверхностную копию списка. Начнём с плохого примера, чтобы
понять пользу копий."""

my_list = [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
new_list = my_list
print(my_list, new_list, sep='\n')
my_list[2] = 555
print(my_list, new_list, sep='\n')

"""Мы скопировали в переменную new_list указатель на список my_list. Далее мы
изменили элемент в исходном списке. Новый список также оказался изменённым.
Как вы помните list — изменяемый тип данных и подобное поведение нормально.
Что делать, если нужно менять оригинал, но не затрагивать копию. Верно. Метод
copy."""

my_list = [2, 4, 6, 2, 8, 10, 12, 14, 16, 18]
new_list = my_list.copy()
print(my_list, new_list, sep='\n')
my_list[2] = 555
print(my_list, new_list, sep='\n')

"""Теперь изменяется лишь один список.


Зачем нужна функция copy.deepcopy()
Иногда программисту приходится работать с вложенными друг в друга
коллекциями. Например матрица или список списков."""

matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
new_m = matrix.copy()
print(matrix, new_m, sep='\n')
matrix[0][1] = 555
print(matrix, new_m, sep='\n')

"""Метод copy создал поверхностную копию, копию верхнего уровня. Изменения же
вложенных объектов отразится и на оригинале. В таком случае для создания
полной копии любой глубины вложенности используют функцию deepcopy из
модуля copy."""

import copy

matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
new_m = copy.deepcopy(matrix)
print(matrix, new_m, sep='\n')
matrix[0][1] = 555
print(matrix, new_m, sep='\n')

"""Функция рекурсивно обходит все вложенные объекты создавая их копии.
Изменения одной коллекции теперь не затрагивают её копию.

Плюсы и минусы создания копии
При работе со списками важно помнить, что сам список как хранитель указателей
на объекты занимает место в памяти. Дополнительно занимают память и сами
объекты, на которые список указывает. Создание копии приводит к новым затратам
памяти, ведь мы создаём новый объект список. Если вы работает с большими
данными, создание копии может быть не лучшей идеей - может не хватить памяти
ПК. Кроме того каждая копия требует временных ресурсов на копирование. Прежде
чем использовать срезы, копии задумайтесь можно ли решить задачу иначе,
экономя время и память.
С другой стороны небольшие списки быстро копируются. И если в вашей задаче
важно сохранить оригинал, но нужно модифицировать список для получения
результата — копирование вполне допустимо."""